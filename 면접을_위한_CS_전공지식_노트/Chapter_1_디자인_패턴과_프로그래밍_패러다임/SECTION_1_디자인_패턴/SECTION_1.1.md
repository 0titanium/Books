# 디자인 패턴

## 디자인 패턴

프로그램 설계 시 발생했던 문제점에 대해 객체 간 상호작용등을 이용하여 해결할 수 있도록 규약의 형태로 만든 것.

## 1.1.1 싱글톤 패턴

하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴.

데이터베이스 연결 모듈에 주로 사용.

- 장점: 하나의 인스턴스를 다른 모듈들이 공유하므로 인스턴스 생성 비용 절약.

- 단점: 의존성이 높아짐. TDD(주로 단위 테스트)에 걸림돌. 테스트들은 독립적이어야 하며 테스트 순서가 상관없어야 하기 때문.

### 의존성 주입 DI Dependency Injection

모듈 간 결합이 강해질 수 있다는 싱글톤 패턴의 단점을 해결.

- 의존성: 종속성. 메인 모듈이 변하면 하위 모듈도 모두 변해야함.

- 의존성 주입자: 메인 모듈이 직접 의존성을 주입하지 않기 위한 중간자.

- 디커플링: 의존성이 떨어짐을 의미하는 단어. 예시) 디커플링 된다. = 의존성이 떨어지게 된다.

- 장점: 모듈을 쉽게 교체 가능 = 테스트 용이 = 마이그레이션 용이. 추상화 레이어를 기반으로한 구현체 = 의존성 방향 일관적, 애플리케이션 추론 용이, 모듈 간 관계 명확.

- 단점: 모듈 분리로 인한 클래스 수 증가, 런타임 패널티

- 원칙: 상위 모듈은 하위 모듈의 어떤 것도 가져오지 않아야 함. 추상화에 의존. 추상화는 세부 사항에 의존하지 말 것.

## 1.1.2 팩토리 패턴

객체 사용 코드에서 객체 생성 부분을 분리, 추상화한 패턴.

상속 관계의 클래스들에서 상위 클래스가 뼈대, 하위 클래스가 객체 생성의 구체성을 담당하는 패턴.

상위, 하위 클래스 분리로 느슨한 결합.

상위 클래스는 인스턴스 생성 방식을 몰라도 되므로 유연해짐.

객체 생성 로직 분리로 유지 보수성 증가 = 코드 리팩토링 시 수정 부분이 적어짐.

## 1.1.3 전략 패턴

정책 패턴이라고도 함.

객체 행위를 바꾸고 싶을 때, 전략이라 부르는 캡슐화한 알고리즘을 컨텍스트 안에서 수정. 상호 교체 가능하게. 직접 수정하지 않음.

### 컨텍스트

어떤 작업을 완료할 때 필요한 모든 관련 정보. 상황, 맥락, 문맥.

## 1.1.4 옵저버 패턴

주체가 어떤 객체의 상태 변화를 관찰. 상태 변화 시 메서드 등을 통해 목록에 있는 옵저버들에게 변화를 알리는 패턴.

주체 = 객체 상태 관찰자.

옵저버 = 추가 변화 사항이 생기는 객체.

주로 이벤트 기반 시스템에 사용.

MVC 패턴에도 사용. 주체 = 모델에 변경 사항 발생, 옵저버 = 뷰에 알림, 컨트롤러 작동.

### 자바의 상속과 구현

- 상속: 자식 클래스가 부모 클래스의 메서드 등을 상속받아 사용, 자식 클래스에서 추가, 확장이 가능. 재사용성, 중복성 최소화.

- 구현: 부모 인터페이스를 자식 클래스에서 재정의하여 구현. 부모 클래스의 메서드 재정의 구현 필수.

- 차이점: 상속은 일반, abstract 클래스 기반. 구현은 인터페이스 기반.

### 프록시 객체

어떤 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체.

### DOM (Document Object Model)

문서 객체 모델. 웹 브라우저 상 화면을 이루는 요소들.

## 1.1.5 프록시 패턴과 프록시 서버

