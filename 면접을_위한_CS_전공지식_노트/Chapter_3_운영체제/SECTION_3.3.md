# 3.3 프로세스와 스레드

프로세스 : 실행 중인 프로그램

작업 task : CPU 스케쥴링 대상

스레드 : 프로세스 내 작업 흐름

프로그램이 메모리에 올라감 -> 프로세스가 됨(인스턴스화)

OS 스케쥴러에 따라 CPU가 프로세스를 실행

## 3.3.1 프로세스와 컴파일 과정

프로세스는 프로그램이 메모리에 올라가 인스턴스화 된 것.

프로그램이 만들어지는 과정은 언어마다 다를 수 있다.

컴파일 언어 : 컴파일러가 컴파일 과정을 통해 기계어로 번역하고 프로그램을 만든다.

(소스 코드) -> 전처리기 -> 컴파일러 -> (어셈블리어) -> 어셈블러 -> (목적코드) + 라이브러리 -> 링커 -> 실행 파일

전처리 : 주석 제거, 헤더 파일 병합 -> 매크로(#define) 치환

컴파일러 : 오류 처리, 코드 최적화, 어셈블리어로 변환

어셈블러 : 목적 코드로 변환.

링커 : 라이브러리 함수, 다른 파일 등을 목적 코드와 합쳐 실행 프로그램(.exe, .out)을 만든다.

정적 라이브러리 : 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는다.
 - 장점 : 시스템 환경 등 외부 의존도가 낮다.
 - 단점 : 코드 중복 등 메모리 효율이 낮다.

동적 라이브러리 : 프로그램 실행 시 DLL(함수 정보)를 참조해 라이브러리를 쓴다.
 - 장점 : 메모리 효율이 좋다.
 - 단점 : 외부 의존도가 높다.

## 3.3.2 프로세스 상태

생성, 대기, 대기 중단, 중단, 일시 중단, 실행, 종료

생성 : 프로세스가 생성된 상태. fork()나 exec() 함수를 통해 생성. PCB가 할당됨.

대기 : 메모리가 충분하면 메모리 할당, 부족하면 아닌 상태로 대기. CPU 스케쥴러로부터 CPU 소유권이 넘어오길 기다림.

대기 중단 : 메모리 부족으로 일시 중단.

실행 : CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중. CPU burst라고도 함.

중단 : 어떤 이벤트 발생 후 기다리며 프로세스가 차단된 상태. 입출력 장치에 의한 인터럽트로도 많이 발생.

일시 중단 : 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 중단.

종료 : 메모리와 CPU 소유권을 놓고 가는 상태.

## 3.3.3 프로세스의 메모리 구조

동적 영역(스택, 힙), 정적 영역(데이터 영역, 코드 영역)

스택 : 
  - 위 주소부터 할당. 
  - 동적 할당(런타임에 할당). 
  - 변수와 함수에 의해 크기가 변하는 메모리 영역. 
  - 함수 호출마다 호출 환경 등의 정보가 쌓임. 
  - 재귀 함수 호출 시 매번 새 스택 프레임이 사용되어 함수 내 변수들이 다른 변수 방해 안함.

힙 : 
  - 아래 주소부터 할당. 
  - 동적 할당 변수들 담는다. 
  - malloc(), free() 등 함수로 관리. 
  - 동적으로 관리되는 자료 구조가 사용.

데이터 영역 : 
  - 정적 할당(컴파일 타임에 할당). BSS segment, Data segment, code/text segment로 나뉨.
  - BSS segment : 전역 변수, static, const로 선언됨. 0 또는 초기화되지 않은 변수들이 할당됨.
  - Data segment : 전역 변수, static, const로 선언됨. 0이 아닌 값으로 초기화된 변수들이 할당됨.
  - code segment : 프로그램 코드.

코드 영역 :

## 3.3.4 PCB

Process Control Block

OS에서 프로세스에 대한 메타데이터를 저장한 데이터.

OS는 프로세스가 생성되면 해당 PCB를 생성함.

프로그램 실행 -> 프로세스 생성 -> 프로세스 주소값에 메모리 할당(스택, 힙 등 기반) -> PCB에 프로세스 메타데이터 저장

중요한 정보라 쉽게 접근 못하게 커널 스택 가장 앞부분에서 관리

메타데이터 : 데이터에 관한 구조화된 데이터. 데이터를 설명하는 데이터.

### PCB 구조

프로세스 스케쥴링 상태 : '준비', '일시중단' 등 프로세스가 CPU에 대한 소유권을 얻은 후의 상태

프로세스 ID : 프로세스 ID와 그 자식 프로세스 ID

프로세스 권한 : 자원이나 입출력 장치에 대한 권한 정보

프로그램 카운터(PC) : 프로세스에서 실행해야할 다음 명령어 주소에 대한 포인터

CPU 레지스터 : 프로세스에서 실행을 위해 저장해야할 레지스터에 대한 정보

CPU 스케쥴링 정보 : CPU 스케쥴러에 의해 중단된 시간 등의 정보

계정 정보 : 프로세스 실행에 사용된 CPU 사용량, 실행한 유저의 정보

I/O 상태 정보 : 프로세스에 할당된 입출력 장치 목록

### 컨텍스트 스위칭

PCB 기반으로 프로세스 상태 저장, 로드 과정

프로세스의 할당 시간 종료나 인터럽트에 의해 발생

프로세스 A 실행 -> 중단 -> 프로세스 A의 PCB 저장 -> 프로세스 B 로드, 실행

-> 중단 -> 프로세스 B의 PCB 저장


컨텍스트 스위칭 비용 : 
 - 유휴 시간(idle time) : 프로세스를 저장하고 다른 프로세스를 로드할 때 걸리는 시간
 - 캐시 미스 : 컨텍스트 스위칭 시 프로세스가 가진 메모리 주소가 그대로 있으면 잘못된 주소 변환 생김. -> 캐시 클리어 -> 캐시 미스 발생.

스레드에서 컨텍스트 스위칭 : 스택을 제외한 모든 메모리 공유 -> 비용, 시간 적음

## 3.3.5 멀티프로세싱

여러 프로세스를 통해 동시에 여러 작업을 수행하는 것

병렬 처리가 가능. 특정 프로세스에 문제가 생겨도 다른 프로세스로 처리 가능 = 신뢰성 높음

하드웨어 관점에선 여러 프로세서로 작업을 처리하는 것

## IPC

Inter Process Communication

프로세스 간 데이터 전달, 공유 데이터 관리 메커니즘

클라이언트, 서버간 데이터 요청, 응답도 예시 중 하나

종류 : 공유 메모리, 파일, 소켓, 익명 파이프, 명명 파이프, 메시지 큐

메모리 완전 공유인 스레드보다는 속도 느림

### 공유 메모리

여러 프로세스에 동일 메모리 블록에 대한 접근 권한이 부여 -> 공유 메모리로 프로세스 간 통신

공유 메모리로 여러 프로세스가 하나의 메모리 공유 가능. 기본적으론 한 프로세스가 다른 프로세스 메모리에 접근 불가

불필요한 데이터 복사의 오버헤드가 발생하지 않음 -> 가장 빠름

같은 메모리 영역을 여러 프로세스가 공유 -> 동기화 필요

하드웨어 관점에선 RAM을 가리킴

### 파일

디스크에 저장된 데이터, 파일 서버에서 제공한 데이터를 기반으로 프로세스 간 통신

### 소켓

동일 컴퓨터의 다른 프로세스, 네트워크 내부의 다른 컴퓨터로 네트워크 인터페이스를 통해 전송하는 데이터.

TCP, UDP

### 익명 파이프

unamed pipe

프로세스 간 FIFO 방식으로 읽히는 임시공간(= 파이프)를 기반으로 데이터 주고 받음

단방향 읽기 전용, 쓰기 전용 파이프를 만들어 작동하는 방식

부모 자식 프로세스 간에만 사용 가능, 다른 네트워크 상에선 불가

### 명명된 파이프

named pipe

파이프 서버와 하나 이상의 파이프 클라이언트 간 통신을 위한 명명된 단/양방향 파이프

클라이언트/서버 통신을 위한 별도 파이프 제공

여러 파이프 동시에 사용 가능

프로세스 간, 다른 네트워크 컴퓨터 간 통신 가능

클라이언트용, 서버용으로 구분해서 작동

하나/여러 개 인스턴스 기반으로 통신

### 메시지 큐

메시지를 큐 형태로 관리

커널에서 전역으로 관리

장점: 직관적, 간단함, 다른 코드 수정없이 몇 줄 코드 추가로 메시지 큐에 접근 가능

공유 메모리로 IPC 구현할 때 읽기/쓰기 빈도가 높으면 동기화 때문에 기능 구현 복잡해짐

그 대안으로 메시지 큐 사용

## 3.3.6 스레드와 멀티스레딩

### 스레드

프로세스의 가장 작은 실행 단위

프로세스는 여러 스레드를 가질 수 있음

힙, 데이터, 코드를 스레드 간 공유. 그 외 영역은 각각 생성됨

### 멀티스레딩

프로세스 내 작업을 멀티 스레드로 처리하는 기법

스레드끼리 자원 공유 -> 효율성 높음

한 스레드가 중단되어도 다른 스레드는 실행 상태일수도 있어서 중단없이 빠른 처리 가능

동시성에도 장점

한 스레드에 문제 -> 다른 스레드에도 영향을 끼쳐 프로세스에 영향을 줄 수 있음

### 동시성

서로 독립적인 작업들을 작은 단위로 나눠 동시에 실행되는 것처럼 보여줌

## 3.3.7 공유 자원과 임계 영역

### 공유 자원

시스템 안에서 프로세스, 스레드가 함께 접근할 수 있는 자원, 변수

공유 자원을 두 개 이상의 프로세스가 동시에 읽고 쓰는 상황을 경쟁 상태(race condition)이라고 함

접근 타이밍이나 순서가 결과에 영향을 줄 수 있는 상태

### 임계 영역

둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역

해결법 : 뮤텍스, 세마포어, 모니터

해결법의 조건 : 상호 배제, 한정 대기, 융통성

해결법의 메커니즘 : 잠금(lock)

### 상호 배제

한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다

### 한정 대기

특정 프로세스가 임계 영역에 영원히 들어갈 수 없으면 안된다

### 융통성

임계 영역을 사용하는 프로세스가 없으면 외부의 어떤 프로세스라도 들어갈 수 있다

프로세스끼리 방해하지 않는다

### 뮤텍스

프로세스/스레드가 공유 자원을 locK()으로 잠금, 사용 후 unlock()으로 해제하는 객체

### 세마포어

일반화된 뮤텍스

간단한 정수 값, 두 함수 wait(혹은 P)와 signal(혹은 V)로 공유 자원에 대한 접근 처리

wait() : 자기 차례까지 대기하는 함수

signal() : 다음 프로세스로 순서 넘겨주는 함수

프로세스/스레드가 공유 자원에 접근 -> 세마포어에서 wait() 수행

프로세스/스레드가 공유 자원 해제 -> 세마포어에서 signal() 수행

조건 변수 없음

한 프로세스/스레드가 세마포어 값 수정 때 동시에 다른 프로세스/스레드가 값 수정 불가

### 바이너리 세마포어

0과 1 값만 가질 수 있는 세마포어

뮤텍스 : 잠금 기반으로 상호 배제. 잠금 메커니즘

세마포어 : 신호 기반으로 상호 배제. 신호 메커니즘

### 카운팅 세마포어

여러 값을 가질 수 있는 세마포어

여러 자원에 대한 접근 제어

### 모니터

여러 프로세스/스레드가 안전하게 공유 자원에 접근할 수 있게 공유 자원을 숨기고 해당 접근에 대한 인터페이스만 제공

모니터 큐를 통해 공유 자원에 대한 작업을 순차적으로 처리

세마포어보다 구현 쉬움

모니터 : 상호 배제 자동

세마포어 : 상호 배제 명시적 구현 필요

## 3.3.8 교착 상태

dead lock

여러 프로세스가 서로 가진 자원을 기다리며 중단된 상태

프로세스 A가 프로세스 B의 자원 요청 <--> 프로세스 B도 프로세스 A의 자원 요청

### 교착 상태 원인

상호 배제 : 한 프로세스가 자원을 독점해 다른 프로세스가 접근 불가

점유 대기 : 특정 프로세스가 점유한 자원을 다른 프로세스가 요청하는 상태

비선점 : 다른 프로세스의 자원을 강제로 가져올 수 없음

환형 대기 : 프로세스 A, B가 서로의 자원을 요청하는 상태

### 교착 상태 해결법

1. 자원 할당 시 애초에 조건 설립이 불가능하게 설계

2. 은행원 알고리즘 사용

3. 교착 상태 발생 시 사이클을 찾고 관련된 프로세스를 하나씩 지움

4. 매우 드문 경우라 처리 비용이 더 크므로 발생 시 작업 종료.

### 은행원 알고리즘

교착 상태 발생 가능성이 없을 때만 자원 할당

프로세스 당 요청할 자원의 최대치로 자원 할당 가능 여부를 파악

총 자원의 양, 현재 할당 가능한 자원의 양을 기준으로 안정, 불안정 상태로 나눔

안정 상태로 가도록 자원을 할당하는 알고리즘
